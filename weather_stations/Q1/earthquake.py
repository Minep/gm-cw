import numpy as np
from matplotlib import pyplot as plt
import itertools
import math

def value(e, station):
    return 1/(0.1 + (e[0]-station[0])**2 + (e[1] - station[1])**2)

def earthquake_exercise_setup(station_number, std, number_of_points = 2000):
    # explosion detector (using spiral coordinate system)
    # define the coordinate system:
    points_on_spiral = number_of_points # number of points on the spiral
    rate = 25 # angular rate of spiral

    spiral_coord = np.zeros((points_on_spiral, 2))
    
    for i in range(points_on_spiral):
        theta = rate * 2*np.pi * i/points_on_spiral
        r = i / points_on_spiral
        spiral_coord[i, 0] = r * np.cos(theta)
        spiral_coord[i, 1] = r * np.sin(theta)

    # define the locations of the detection stations on the surface
    # Also define what value on each sensor would be generated by an explostion at internal location

    station_coord = np.zeros((station_number, 2))
    for station in range(station_number):
        # get the coordinate for each station/sensor
        theta_sensor = 2*np.pi * station/station_number
        station_coord[station, 0] = np.cos(theta_sensor) # x
        station_coord[station, 1] = np.sin(theta_sensor) # y

    # construct hypothesis for single explosion
    hypothesis = np.zeros((points_on_spiral, station_number))
    for s in range(points_on_spiral):
        for i in range(station_number):
            hypothesis[s, i] = value(spiral_coord[s], station_coord[i])

    
    # combine to get two explosions hypothesis
    all_stations_prior = []
    for station in range(station_number):
        v = np.zeros((points_on_spiral, points_on_spiral))
        for j in range(points_on_spiral):
            for k in range(points_on_spiral):
                v[j,k] = hypothesis[j, station] + hypothesis[k, station] + std*np.random.randn()
        all_stations_prior.append(v)

    
    return all_stations_prior, spiral_coord, station_coord, hypothesis

def norm_pdf(value, mu, sigma):
    """
    Calculate the pdf of normal distribution
    """
    var = sigma**2
    denom = np.sqrt(2*math.pi*var)
    num = np.exp(-(value - mu)**2 / (2*var))
    return num/denom

def q1(data, number_of_points, std, all_stations, spiral_coord, station_coord):
    """
    Question 1
    """
    station_number = data.size
    likelihood = np.ones((number_of_points, number_of_points))

    for station in range(station_number):
        likelihood *= norm_pdf(data[station], all_stations[station][:], std)

    total_post = np.sum(likelihood, axis = 0)
    # sort of normalize
    total_post = total_post ** 0.1

    plt.figure(figsize=(10,10)) 
    plt.xlim([-2,2])
    plt.ylim([-2,2])
    # plot stations
    plt.scatter(station_coord[:, 0], station_coord[:, 1])
    # plot point values
    plt.scatter(spiral_coord[:, 0], spiral_coord[:, 1], c=-total_post, cmap='gray', s = total_post*10) 
    # plot station record values
    scaled = data/ 10 + 1
    for station in range(station_number):
        theta_sensor = 2*np.pi * station/station_number
        start = [station_coord[station, 0],((scaled[station])*np.cos(theta_sensor))] 
        end = [station_coord[station, 1], ((scaled[station])*np.sin(theta_sensor))]
        plt.plot(start, end,"-", color='red')   

    # get the largest 2
    most = np.argsort(total_post)[-2:]
    # print(most)
    plt.scatter(spiral_coord[most, 0], spiral_coord[most, 1], marker="x", label="estimated")
    plt.legend()
    plt.show()

def q2(data, number_of_points, std, all_stations, one_explosion):
    # compute log likelihood
    station_number = data.size

    likelihood2 = np.ones((number_of_points, number_of_points))
    for station in range(station_number):
        likelihood2 *= norm_pdf(data[station], all_stations[station][:], std)

    likelihood2 = np.log(np.sum(likelihood2))


    likelihood1 = np.ones(number_of_points)
    for station in range(station_number):
        likelihood1 *= norm_pdf(data[station], one_explosion[:, station], std)

    likelihood1 = np.log(np.sum(likelihood1))
    print(np.sum(likelihood2 - likelihood1))

if __name__ == "__main__":
    data = np.loadtxt("earthquake_files\EarthquakeExerciseData.txt")
    number_of_points = 2000
    std = 0.2
    station_number = data.size
    all_stations_prior, spiral_coord, station_coord, one_explosion = earthquake_exercise_setup(station_number, std, number_of_points=number_of_points)
    q1(data, number_of_points, std, all_stations_prior, spiral_coord, station_coord)
    q2(data, number_of_points, std, all_stations=all_stations_prior, one_explosion=one_explosion)